Sharing = require '../lib/sharing'
async = require 'async'

addAccess = require('../lib/token').addAccess
db = require('../helpers/db_connect_helper').db_connect()

# Define random function for application's token
randomString = (length) ->
    string = ""
    while (string.length < length)
        string = string + Math.random().toString(36).substr(2)
    return string.substr 0, length

# ---Â Creation of the share document.
# The share document is a document that represents the sharing process that was
# initiated and that we store in the database for further use.
#
# The structure of a share document is as following
# shareDoc {
#   id        -> the id of the sharing process
#   fDoc      -> a filter on the documents to determine which documents need to
#                be shared
#   fUser     -> a filter on the users to determine to whom we need to share
#                the documents
#   desc      -> a description of the sharing process
#   docIDs[]  -> an array containing the ids of the documents to share. These
#                ids were determined thanks to the filter "fDoc"
#   targets[] -> an array containing the users to whom the documents will be
#                shared. This array contains "target" a custom structure that
#                will hold all the information required to share with that
#                particular user.
# }
#
# The structure target:
# target {
#   url           -> the url of the user's cozy
#   pwd           -> the password linked to the sharing process
#   replicationID -> the id generated by CouchDB for the replication. The
#                    replication is a process linked to Couch in order to
#                    replicate documents between Couch instances.
# }
#
# We suppose in this function that the data we receive is already in the
# correct format. That means we will receive a "share" object that has all its
# fields filled as needed.
#
module.exports.create = (req, res, next) ->
    # get a hold on the information
    share = req.body
    # check if the information is available
    if not share?
        err = new Error "Bad request"
        err.status = 400
        next err
    else
        # put the share document in the database
        db.save share, (err, res) ->
            if err?
                next err
            else
                share.id = res._id
                req.share = share
                next()


# Send a sharing request for each target defined in the share object
module.exports.requestTarget = (req, res, next) ->
    if not req.share?
        err = new Error "Bad request"
        err.status = 400
        next err
    else
        share = req.share
        request =
            shareID: share.id
            desc: share.desc
            sync: share.sync
            hostUrl: share.hostUrl

        # Notify each target
        async.each share.targets, (target, callback) ->
             Sharing.notifyTarget target.url, request, (err, result, body) ->
                if err?
                    callback err
                else if not result?.statusCode?
                    err = new Error "Bad request"
                    err.status = 400
                    callback err
                else
                    res.send result.statusCode, body
                    callback()

        , (err) ->
            return next err if err?


# Create access if the sharing answer is yes, remove the UserSharing doc otherwise.

module.exports.handleAnswer = (req, res, next) ->

    ### Params must contains :
    id (usersharing)
    shareID
    accepted
    targetUrl
    docIDs
    hostUrl
    ###


    if not req.body?
        err = new Error "Bad request"
        err.status = 400
        next err
    params = req.body

    # Create an access is the sharing is accepted
    if params.accepted is yes
        access =
            login: params.shareID
            password: randomString 32
            id: params.id
            permissions: params.docIDs

        addAccess access, (err, doc) ->
            return next err if err?
            
            params.pwd = access.password
            req.params = params
            next()           

    # Delete the associated doc if the sharing is refused
    else
        db.remove req.params.id, (err, res) ->
            return next err if err?
            req.params = params
            next()

# Send the answer to the host
module.exports.sendAnswer = (req, res, next) ->
    console.log 'params ' + JSON.stringify req.params 

    answer = 
        shareID: req.params.shareID
        url: req.params.url
        accepted: req.params.accepted
        pwd: req.params.pwd

    Sharing.answerHost req.params.hostUrl, answer, (err, result, body) ->
        if err? 
            next err
        else if not result?.statusCode?
            err = new Error "Bad request"
            err.status = 400
            next err
        else
            console.log 'body : ' + JSON.stringify body
            res.send result.statusCode, body




# Process the answer given by the target regarding the sharing request that was
# sent to him.
#
# The structure of the answer received is as following:
# answer {
#   shareID    -> the id of the sharing request
#   url        -> the url of the target
#   accepted   -> wether or not the target has accepted the request
#   pwd        -> the password generated by the target
# }
#
module.exports.validateTarget = (req, res, next) ->
    console.log 'answer : ' + JSON.stringify req.body
    
    answer = req.body
    if not answer?
        # send an error explaining that the answer received has not the
        # expected format or just isn't there
        err = new Error "Bad request"
        err.status = 400
        next err

    else
        # we get a hold on the share document stored in the database that
        # represents this sharing process
        db.get answer.shareID, (err, doc) ->
            return next err if err?
            console.log 'share doc : ' + JSON.stringify doc

            # we get the index of the current target in the array containing all
            # the targets of the sharing process
            target_index = doc.targets.indexOf answer.url
            if target_index > -1
                err = new Error answer.url + " not found for this sharing"
                err.status = 404
                next err
            else
                # Then we check if the target has accepted the request
                # Add the password to the share document if accepted
                # Remove the target otherwise        
                if answer.accepted            
                    doc.targets[target_index].pwd = answer.pwd
                else
                    doc.targets.splice target_index, 1

                db.merge doc._id, doc, (err, res) ->
                    return next err if err?
                    
                    # we create a params structure for the replication function
                    params =
                        pwd: answer.pwd
                        url: answer.url
                        id: doc._id
                        docIDs: doc.docIDs
                        sync: doc.isSync

                    req.params = params
                    next()


module.exports.update = (req, res, next) ->
    # push the modification of the share document in the database and if
    # this operation was successful launch the replication!
    db.merge req.doc._id, req.doc, (err, res) ->
        if err?
            next err
        else
            # we create a params structure for the replication function
            params =
                pwd: req.answer.pwd
                url: req.answer.url
                id: shareDoc.id
                docIDs: shareDoc.docIDs
                isSync: shareDoc.isSync


            next()


module.exports.replicate = (req, res, next) ->
    params = req.params
    # Replicate on the validated target
    if params.pwd?
        Sharing.replicateDocs params, (err) ->
            return next err if err?
            res.send 200, success: true
    else
        res.send 200, success: true
