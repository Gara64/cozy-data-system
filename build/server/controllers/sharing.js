// Generated by CoffeeScript 1.10.0
var Sharing, TOKEN_LENGTH, addAccess, async, crypto, db, generateToken;

Sharing = require('../lib/sharing');

async = require('async');

crypto = require("crypto");

addAccess = require('../lib/token').addAccess;

db = require('../helpers/db_connect_helper').db_connect();

TOKEN_LENGTH = 32;

generateToken = function(length) {
  return crypto.randomBytes(length).toString('hex');
};

module.exports.create = function(req, res, next) {
  var err, fn, j, len, ref, ref1, share, target;
  share = req.body;
  if (!(((ref = share.targets) != null ? ref.length : void 0) > 0)) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  }
  share.docType = "sharing";
  ref1 = share.targets;
  fn = function(target) {
    return target.preToken = generateToken(TOKEN_LENGTH);
  };
  for (j = 0, len = ref1.length; j < len; j++) {
    target = ref1[j];
    fn(target);
  }
  return db.save(share, function(err, res) {
    if (err != null) {
      return next(err);
    } else {
      share.shareID = res._id;
      req.share = share;
      return next();
    }
  });
};

module.exports["delete"] = function(req, res, next) {
  var err, shareID;
  shareID = req.params.id;
  if (shareID == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    return db.get(shareID, function(err, doc) {
      var share;
      if (err != null) {
        return next(err);
      } else {
        share = {
          shareID: shareID,
          targets: doc.targets
        };
        return db.remove(shareID, function(err, res) {
          if (err != null) {
            return next(err);
          }
          req.share = share;
          return next();
        });
      }
    });
  }
};

module.exports.sendSharingRequests = function(req, res, next) {
  var err, share;
  share = req.share;
  if (req.share == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    return async.each(share.targets, function(target, callback) {
      var request;
      request = {
        url: target.url,
        preToken: target.preToken,
        shareID: share.shareID,
        rules: share.rules,
        desc: share.desc
      };
      return Sharing.notifyTarget("services/sharing/request", request, function(err, result) {
        return callback(err);
      });
    }, function(err) {
      if (err != null) {
        return next(err);
      } else {
        return res.status(200).send({
          success: true
        });
      }
    });
  }
};

module.exports.sendDeleteNotifications = function(req, res, next) {
  var err, share;
  share = req.share;
  if (req.share == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    return async.each(share.targets, function(target, callback) {
      var notif;
      notif = {
        url: target.url,
        token: target.token,
        shareID: share.shareID,
        desc: "The sharing " + share.shareID + " has been deleted"
      };
      return Sharing.notifyTarget("services/sharing/cancel", notif, function(err, result) {
        return callback(err);
      });
    }, function(err) {
      if (err != null) {
        return next(err);
      } else {
        return res.status(200).send({
          success: true
        });
      }
    });
  }
};

module.exports.handleRecipientAnswer = function(req, res, next) {
  var access, err, share;
  share = req.body;
  if (!((share.id != null) && (share.shareID != null) && (share.accepted != null) && (share.url != null) && (share.rules != null) && (share.hostUrl != null))) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  }
  if (share.accepted === true) {
    access = {
      login: share.shareID,
      password: generateToken(TOKEN_LENGTH),
      id: share.id,
      rules: share.rules
    };
    return addAccess(access, function(err, doc) {
      if (err != null) {
        return next(err);
      }
      share.token = access.password;
      req.share = share;
      return next();
    });
  } else {
    return db.remove(share.id, function(err, res) {
      if (err != null) {
        return next(err);
      }
      req.share = share;
      return next();
    });
  }
};

module.exports.sendAnswer = function(req, res, next) {
  var answer, err, share;
  share = req.share;
  if (share == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    answer = {
      shareID: share.shareID,
      url: share.hostUrl,
      accepted: share.accepted,
      preToken: share.preToken,
      token: share.token
    };
    return Sharing.notifyTarget("services/sharing/answer", answer, function(err, result, body) {
      if (err != null) {
        return next(err);
      } else {
        return res.status(200).send({
          success: true
        });
      }
    });
  }
};

module.exports.validateTarget = function(req, res, next) {
  var answer, err;
  answer = req.body;
  if (!((answer.shareID != null) && (answer.hostUrl != null) && (answer.accepted != null))) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  }
  return db.get(answer.shareID, function(err, doc) {
    var i, j, len, ref, t, target;
    if (err != null) {
      return next(err);
    }
    console.log('doc :' + JSON.stringify(doc));
    ref = doc.targets;
    for (j = 0, len = ref.length; j < len; j++) {
      t = ref[j];
      if (t.url === answer.hostUrl) {
        target = t;
      }
    }
    if (target == null) {
      err = new Error(answer.hostUrl + " not found for this sharing");
      err.status = 404;
      return next(err);
    }
    if (target.preToken !== answer.preToken) {
      err = new Error("Unauthorized");
      err.status = 401;
      return next(err);
    }
    if (target.token != null) {
      err = new Error("The answer for this sharing has already been given");
      err.status = 403;
      return next(err);
    }
    if (answer.accepted) {
      target.token = answer.token;
      delete target.preToken;
    } else {
      i = doc.targets.indexOf(target);
      doc.targets.splice(i, 1);
    }
    return db.merge(doc._id, doc, function(err, result) {
      var docIDs, replicate, rule;
      if (err != null) {
        return next(err);
      }
      docIDs = (function() {
        var k, len1, ref1, results;
        ref1 = doc.rules;
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          rule = ref1[k];
          results.push(rule.id);
        }
        return results;
      })();
      replicate = {
        target: target,
        id: doc._id,
        docIDs: docIDs,
        continuous: doc.continuous
      };
      req.replicate = replicate;
      return next();
    });
  });
};

module.exports.replicate = function(req, res, next) {
  var replicate;
  replicate = req.replicate;
  console.log('replicate : ' + JSON.stringify(replicate));
  if (replicate.target.token != null) {
    return Sharing.replicateDocs(replicate, function(err, repID) {
      if (err != null) {
        return next(err);
      } else if (replicate.continuous && (repID == null)) {
        err = "Replication error";
        err.status = 500;
        return next(err);
      } else {
        if (replicate.continuous) {
          return db.get(replicate.id, function(err, doc) {
            var i, j, len, ref, t, target, targetUrl;
            if (err != null) {
              return next(err);
            }
            targetUrl = replicate.target.url;
            ref = doc.targets;
            for (j = 0, len = ref.length; j < len; j++) {
              t = ref[j];
              if (t.url === targetUrl) {
                target = t;
              }
            }
            i = doc.targets.indexOf(target);
            doc.targets[i].repID = repID;
            return db.merge(replicate.id, doc, function(err, result) {
              if (err != null) {
                return next(err);
              }
              return res.status(200).send({
                success: true
              });
            });
          });
        } else {
          return res.status(200).send({
            success: true
          });
        }
      }
    });
  } else {
    return res.status(200).send({
      success: true
    });
  }
};

module.exports.stopReplications = function(req, res, next) {
  var err, share;
  share = req.share;
  if (share == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    return async.each(share.targets, function(target, cb) {
      if (target.repID != null) {
        return Sharing.cancelReplication(target.repID, function(err) {
          return cb(err);
        });
      } else {
        return cb();
      }
    }, function(err) {
      return next(err);
    });
  }
};
