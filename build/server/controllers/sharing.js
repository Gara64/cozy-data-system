// Generated by CoffeeScript 1.10.0
var Sharing, TOKEN_LENGTH, async, crypto, db, generateToken, libToken, log, util;

Sharing = require('../lib/sharing');

async = require("async");

crypto = require("crypto");

util = require('util');

log = require('printit')({
  prefix: 'sharing'
});

libToken = require('../lib/token');

db = require('../helpers/db_connect_helper').db_connect();

TOKEN_LENGTH = 32;

generateToken = function(length) {
  return crypto.randomBytes(length).toString('hex');
};

module.exports.create = function(req, res, next) {
  var err, j, k, l, len, len1, len2, ref, ref1, ref2, ref3, ref4, rule, share, target;
  share = req.body;
  if (!((share != null) && Object.keys(share).length > 0)) {
    err = new Error("Bad request: no body");
    err.status = 400;
    return next(err);
  }
  if (!(((ref = share.targets) != null ? ref.length : void 0) > 0)) {
    err = new Error("No target specified");
    err.status = 400;
    return next(err);
  }
  ref1 = share.targets;
  for (j = 0, len = ref1.length; j < len; j++) {
    target = ref1[j];
    if ((target.url == null) || target.url === '') {
      err = new Error("No url specified");
      err.status = 400;
      return next(err);
    }
  }
  if (!(((ref2 = share.rules) != null ? ref2.length : void 0) > 0)) {
    err = new Error("No rules specified");
    err.status = 400;
    return next(err);
  }
  ref3 = share.rules;
  for (k = 0, len1 = ref3.length; k < len1; k++) {
    rule = ref3[k];
    if ((rule.docType == null) || rule.docType === "" || (rule.id == null) || rule.id === "") {
      err = new Error("Incorrect rule detected");
      err.status = 400;
      return next(err);
    }
  }
  share.docType = "sharing";
  ref4 = share.targets;
  for (l = 0, len2 = ref4.length; l < len2; l++) {
    target = ref4[l];
    target.preToken = generateToken(TOKEN_LENGTH);
  }
  return db.save(share, function(err, res) {
    if (err != null) {
      return next(err);
    } else {
      share.shareID = res._id;
      req.share = share;
      return next();
    }
  });
};

module.exports["delete"] = function(req, res, next) {
  var err, ref, shareID;
  if (((ref = req.params) != null ? ref.id : void 0) == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    shareID = req.params.id;
    return db.get(shareID, function(err, doc) {
      var share;
      if (err != null) {
        return next(err);
      } else {
        share = {
          shareID: shareID,
          targets: doc.targets
        };
        return db.remove(shareID, function(err, res) {
          if (err != null) {
            return next(err);
          }
          req.share = share;
          return next();
        });
      }
    });
  }
};

module.exports.sendSharingRequests = function(req, res, next) {
  var share;
  share = req.share;
  return async.each(share.targets, function(target, callback) {
    var request;
    request = {
      url: target.url,
      preToken: target.preToken,
      shareID: share.shareID,
      rules: share.rules,
      desc: share.desc
    };
    log.info("Send sharing request to : " + request.url);
    return Sharing.notifyTarget("services/sharing/request", request, function(err, result) {
      return callback(err);
    });
  }, function(err) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.sendDeleteNotifications = function(req, res, next) {
  var share;
  share = req.share;
  return async.each(share.targets, function(target, callback) {
    var notif;
    notif = {
      url: target.url,
      token: target.token != null ? target.token : target.preToken,
      shareID: share.shareID,
      desc: "The sharing " + share.shareID + " has been deleted"
    };
    log.info("Send sharing cancel notification to : " + notif.url);
    return Sharing.notifyTarget("services/sharing/cancel", notif, function(err, result) {
      return callback(err);
    });
  }, function(err) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.handleRecipientAnswer = function(req, res, next) {
  var access, err, j, len, ref, rule, share;
  if ((req.body == null) || Object.keys(req.body).length === 0) {
    err = new Error("Bad request: body is missing");
    err.status = 400;
    return next(err);
  }
  share = req.body;
  if ((share.id == null) || share.id === '' || (share.shareID == null) || share.shareID === '' || (share.preToken == null) || share.preToken === '' || (share.accepted == null) || share.accepted === '' || (share.url == null) || share.url === '' || (share.hostUrl == null) || share.hostUrl === '' || (share.rules == null) || (share.rules.length == null) || share.rules.length === 0) {
    err = new Error("Bad request: body is incomplete");
    err.status = 400;
    return next(err);
  }
  ref = share.rules;
  for (j = 0, len = ref.length; j < len; j++) {
    rule = ref[j];
    if ((rule.id == null) || rule.id === '' || (rule.docType == null) || rule.docType === '') {
      err = new Error("Bad request: incorrect rule detected");
      err.status = 400;
      return next(err);
    }
  }
  if (share.accepted === true) {
    access = {
      login: share.shareID,
      password: generateToken(TOKEN_LENGTH),
      id: share.id,
      rules: share.rules
    };
    return libToken.addAccess(access, function(err, doc) {
      if (err != null) {
        return next(err);
      }
      share.token = access.password;
      req.share = share;
      return next();
    });
  } else {
    return db.remove(share.id, function(err, res) {
      if (err != null) {
        return next(err);
      }
      req.share = share;
      return next();
    });
  }
};

module.exports.sendAnswer = function(req, res, next) {
  var answer, share;
  share = req.share;
  answer = {
    shareID: share.shareID,
    hostUrl: share.url,
    url: share.hostUrl,
    accepted: share.accepted,
    preToken: share.preToken,
    token: share.token
  };
  log.info("Send sharing answer to : " + answer.url);
  return Sharing.notifyTarget("services/sharing/answer", answer, function(err, result, body) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.validateTarget = function(req, res, next) {
  var answer, err;
  if ((req.body == null) || Object.keys(req.body).length <= 0) {
    err = new Error("Bad request: body is empty");
    err.status = 400;
    return next(err);
  }
  answer = req.body;
  if ((answer.shareID == null) || answer.shareID === '' || (answer.hostUrl == null) || answer.hostUrl === '' || (answer.accepted == null) || answer.accepted === '' || (answer.preToken == null) || answer.preToken === '' || (answer.token == null) || answer.token === '') {
    err = new Error("Bad request: body is incomplete");
    err.status = 400;
    return next(err);
  }
  return db.get(answer.shareID, function(err, doc) {
    var i, t, target;
    if (err != null) {
      return next(err);
    }
    target = (function() {
      var j, len, ref, results;
      ref = doc.targets;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        if (t.url === answer.hostUrl) {
          results.push(t);
        }
      }
      return results;
    })();
    if (target.length !== 1) {
      err = new Error(answer.hostUrl + " not found for this sharing");
      err.status = 404;
      return next(err);
    }
    target = target[0];
    if ((target.preToken == null) || target.preToken !== answer.preToken) {
      err = new Error("Unauthorized");
      err.status = 401;
      return next(err);
    }
    if (target.token != null) {
      err = new Error("The answer for this sharing has already been given");
      err.status = 403;
      return next(err);
    }
    if (answer.accepted) {
      log.info("Sharing " + answer.shareID + " accepted by " + target.url);
      target.token = answer.token;
      delete target.preToken;
    } else {
      log.info("Sharing " + answer.shareID + " denied by " + target.url);
      i = doc.targets.indexOf(target);
      doc.targets.splice(i, 1);
    }
    return db.merge(doc._id, doc, function(err, result) {
      var docIDs, replicate, rule;
      if (err != null) {
        return next(err);
      }
      docIDs = (function() {
        var j, len, ref, results;
        ref = doc.rules;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          rule = ref[j];
          results.push(rule.id);
        }
        return results;
      })();
      replicate = {
        target: target,
        id: doc._id,
        docIDs: docIDs,
        continuous: doc.continuous
      };
      req.replicate = replicate;
      return next();
    });
  });
};

module.exports.replicate = function(req, res, next) {
  var replicate;
  replicate = req.replicate;
  if (replicate.target.token != null) {
    return Sharing.replicateDocs(replicate, function(err, repID) {
      if (err != null) {
        return next(err);
      } else if (replicate.continuous && (repID == null)) {
        err = new Error("Replication error");
        err.status = 500;
        return next(err);
      } else {
        if (replicate.continuous) {
          return db.get(replicate.id, function(err, doc) {
            var i, t, target, targetUrl;
            if (err != null) {
              return next(err);
            }
            targetUrl = replicate.target.url;
            target = (function() {
              var j, len, ref, results;
              ref = doc.targets;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                t = ref[j];
                if (t.url === targetUrl) {
                  results.push(t);
                }
              }
              return results;
            })();
            i = doc.targets.indexOf(target[0]);
            doc.targets[i].repID = repID;
            return db.merge(replicate.id, doc, function(err, result) {
              if (err != null) {
                return next(err);
              }
              return res.status(200).send({
                success: true
              });
            });
          });
        } else {
          return res.status(200).send({
            success: true
          });
        }
      }
    });
  } else {
    return res.status(200).send({
      success: true
    });
  }
};

module.exports.stopReplications = function(req, res, next) {
  var share;
  share = req.share;
  return async.each(share.targets, function(target, cb) {
    if (target.repID != null) {
      return Sharing.cancelReplication(target.repID, function(err) {
        return cb(err);
      });
    } else {
      return cb();
    }
  }, function(err) {
    return next(err);
  });
};
