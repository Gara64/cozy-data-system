// Generated by CoffeeScript 1.6.3
var Account, Client, CryptoTools, User, accountManager, checkDocType, checkProxyHome, client, correctWitness, cryptoTools, db, encryptPassword, randomString, toString, user,
  _this = this;

load('application');

Client = require("request-json").JsonClient;

Account = require('./lib/account');

CryptoTools = require('./lib/crypto_tools');

User = require('./lib/user');

randomString = require('./lib/random').randomString;

accountManager = new Account();

client = new Client("http://localhost:9102/");

checkProxyHome = require('./lib/token').checkProxyHome;

checkDocType = require('./lib/token').checkDocType;

cryptoTools = new CryptoTools();

user = new User();

db = require('./helpers/db_connect_helper').db_connect();

correctWitness = "Encryption is correct";

before('permission_keys', function() {
  var _this = this;
  return checkProxyHome(req.header('authorization'), function(err, isAuthorized) {
    if (!isAuthorized) {
      err = new Error("Application is not authorized");
      return send({
        error: err
      }, 403);
    } else {
      return next();
    }
  });
}, {
  only: ['initializeKeys', 'updateKeys', 'deleteKeys', 'resetKeys']
});

before('permission', function() {
  var auth,
    _this = this;
  auth = req.header('authorization');
  return checkDocType(auth, "Account", function(err, appName, isAuthorized) {
    if (!appName) {
      err = new Error("Application is not authenticated");
      return send({
        error: err
      }, 401);
    } else if (!isAuthorized) {
      err = new Error("Application is not authorized");
      return send({
        error: err
      }, 403);
    } else {
      compound.app.feed.publish('usage.application', appName);
      return next();
    }
  });
}, {
  only: ['createAccount', 'findAccount', 'existAccount', 'updateAccount', 'upsertAccount', 'deleteAccount', 'deleteAllAccounts', 'mergeAccount']
});

before('get doc with witness', function() {
  var _this = this;
  return db.get(params.id, function(err, doc) {
    var slaveKey, witness;
    if (err && err.error === "not_found") {
      return send(404);
    } else if (err) {
      console.log("[Get doc] err: " + err);
      return send(500);
    } else if (doc != null) {
      if ((app.crypto != null) && app.crypto.masterKey && app.crypto.slaveKey) {
        slaveKey = cryptoTools.decrypt(app.crypto.masterKey, app.crypto.slaveKey);
        if (doc.witness != null) {
          try {
            witness = cryptoTools.decrypt(slaveKey, doc.witness);
            if (witness === correctWitness) {
              _this.doc = doc;
              return next();
            } else {
              console.log("[Get doc] err: data are corrupted");
              return send(402);
            }
          } catch (_error) {
            err = _error;
            console.log("[Get doc] err: data are corrupted");
            return send(402);
          }
        } else {
          witness = cryptoTools.encrypt(slaveKey, correctWitness);
          return db.merge(params.id, {
            witness: witness
          }, function(err, res) {
            if (err) {
              console.log("[Merge] err: " + err);
              return send(500);
            } else {
              _this.doc = doc;
              return next();
            }
          });
        }
      } else {
        console.log("err : master key and slave key don't exist");
        return send(500);
      }
    } else {
      return send(404);
    }
  });
}, {
  only: ['findAccount', 'updateAccount', 'mergeAccount']
});

before('get doc', function() {
  var _this = this;
  return db.get(params.id, function(err, doc) {
    if (err && err.error === "not_found") {
      return send(404);
    } else if (err) {
      console.log("[Get doc] err: " + err);
      return send(500);
    } else if (doc != null) {
      _this.doc = doc;
      return next();
    } else {
      return send(404);
    }
  });
}, {
  only: ['deleteAccount']
});

encryptPassword = function(body, callback) {
  var app, newPwd, slaveKey, witness;
  app = compound.app;
  if (body.password) {
    if ((app.crypto != null) && app.crypto.masterKey && app.crypto.slaveKey) {
      slaveKey = cryptoTools.decrypt(app.crypto.masterKey, app.crypto.slaveKey);
      newPwd = cryptoTools.encrypt(slaveKey, body.password);
      body.password = newPwd;
      body.docType = "Account";
      witness = cryptoTools.encrypt(slaveKey, correctWitness);
      body.witness = witness;
      return callback(true);
    } else {
      return callback(false, new Error("master key and slave key don't exist"));
    }
  } else {
    return callback(false);
  }
};

toString = function() {
  return "[Account for model: " + this.id + "]";
};

action('initializeKeys', function() {
  return user.getUser(function(err, user) {
    var data, encryptedSlaveKey, masterKey, salt, slaveKey,
      _this = this;
    if (err) {
      console.log("[initializeKeys] err: " + err);
      return send(500);
    } else {
      if (app.crypto == null) {
        app.crypto = {};
      }
      if ((user.salt != null) && (user.slaveKey != null)) {
        app.crypto.masterKey = cryptoTools.genHashWithSalt(body.password, user.salt);
        app.crypto.slaveKey = user.slaveKey;
        send({
          success: true
        });
        if (app.crypto.masterKey.length !== 32) {
          console.log("[initializeKeys] err: password to initialize                        keys is different than user password");
          return send(500);
        }
      } else {
        salt = cryptoTools.genSalt(32 - body.password.length);
        masterKey = cryptoTools.genHashWithSalt(body.password, salt);
        slaveKey = randomString();
        encryptedSlaveKey = cryptoTools.encrypt(masterKey, slaveKey);
        app.crypto.masterKey = masterKey;
        app.crypto.slaveKey = encryptedSlaveKey;
        data = {
          salt: salt,
          slaveKey: encryptedSlaveKey
        };
        return db.merge(user._id, data, function(err, res) {
          if (err) {
            console.log("[initializeKeys] err: " + err);
            return send(500);
          } else {
            console.log('key intialized');
            return send({
              success: true
            });
          }
        });
      }
    }
  });
});

action('updateKeys', function() {
  if (body.password != null) {
    return user.getUser(function(err, user) {
      var data, salt, slaveKey,
        _this = this;
      if (err) {
        console.log("[updateKeys] err: " + err);
        return send(500);
      } else {
        if ((app.crypto != null) && (app.crypto.masterKey != null) && (app.crypto.slaveKey != null)) {
          if (app.crypto.masterKey.length !== 32) {
            console.log("[initializeKeys] err: password to                            initialize keys is different than user password");
            return send(500);
          } else {
            slaveKey = cryptoTools.decrypt(app.crypto.masterKey, app.crypto.slaveKey);
            salt = cryptoTools.genSalt(32 - body.password.length);
            app.crypto.masterKey = cryptoTools.genHashWithSalt(body.password, salt);
            app.crypto.slaveKey = cryptoTools.encrypt(app.crypto.masterKey, slaveKey);
            data = {
              slaveKey: app.crypto.slaveKey,
              salt: salt
            };
            return db.merge(user._id, data, function(err, res) {
              if (err) {
                console.log("[updateKeys] err: " + err);
                return send(500);
              } else {
                return send({
                  success: true
                });
              }
            });
          }
        } else {
          console.log("[updateKeys] err: masterKey and slaveKey don't\                        exist");
          return send(500);
        }
      }
    });
  } else {
    return send(500);
  }
});

action('resetKeys', function() {
  return user.getUser(function(err, user) {
    var data,
      _this = this;
    if (err) {
      console.log("[updateKeys] err: " + err);
      return send(500);
    } else {
      if (app.crypto != null) {
        app.crypto = null;
      }
      data = {
        slaveKey: null,
        salt: null
      };
      return db.merge(user._id, data, function(err, res) {
        if (err) {
          console.log("[resetKeys] err: " + err);
          return send(500);
        } else {
          return send({
            success: true
          }, 204);
        }
      });
    }
  });
});

action('deleteKeys', function() {
  if ((app.crypto != null) && app.crypto.masterKey && app.crypto.slaveKey) {
    app.crypto.masterKey = null;
    app.crypto.slaveKey = null;
    return send({
      sucess: true
    }, 204);
  } else {
    console.log("[deleteKeys] err: masterKey and slaveKey don't exist");
    return send({
      error: "masterKey and slaveKey don't exis"
    }, 500);
  }
});

action('createAccount', function() {
  body.docType = "Account";
  body.toString = toString;
  return encryptPassword(body, function(pwdExist, err) {
    if (err) {
      console.log("[createAccount] err: " + err);
      return send(500);
    } else {
      if (pwdExist) {
        return db.save(body, function(err, res) {
          if (err) {
            railway.logger.write("[createAccount] err: " + err);
            return send(500);
          } else {
            return send({
              _id: res._id
            }, 201);
          }
        });
      } else {
        return send(401);
      }
    }
  });
});

action('findAccount', function() {
  var encryptedPwd, slaveKey;
  delete this.doc._rev;
  if (this.doc.password != null) {
    encryptedPwd = this.doc.password;
    slaveKey = cryptoTools.decrypt(app.crypto.masterKey, app.crypto.slaveKey);
    this.doc.password = cryptoTools.decrypt(slaveKey, encryptedPwd);
    this.doc.toString = toString;
    return send(this.doc);
  } else {
    return send(500);
  }
});

action('existAccount', function() {
  return db.head(params.id, function(err, res, status) {
    if (status === 200) {
      return send({
        exist: true
      });
    } else if (status === 404) {
      return send({
        exist: false
      });
    }
  });
});

action('updateAccount', function() {
  return encryptPassword(body, function(pwdExist, err) {
    if (err) {
      console.log("[updateAccount] err: " + err);
      return send(500);
    } else {
      if (pwdExist) {
        return db.save(params.id, body, function(err, res) {
          if (err) {
            console.log("[updateAccount] err: " + err);
            return send(500);
          } else {
            return send({
              success: true
            });
          }
        });
      } else {
        return send(401);
      }
    }
  });
});

action('mergeAccount', function() {
  return encryptPassword(body, function(pwdExist, err) {
    if (err) {
      console.log("[mergeAccount] err: " + err);
      return send(500);
    } else {
      return db.merge(params.id, body, function(err, res) {
        if (err) {
          console.log("[Merge] err: " + err);
          return send(500);
        } else {
          return send({
            success: true
          });
        }
      });
    }
  });
});

action('upsertAccount', function() {
  return encryptPassword(body, function(pwdExist, err) {
    if (pwdExist && !err) {
      return db.get(params.id, function(err, doc) {
        return db.save(params.id, body, function(err, res) {
          if (err) {
            console.log("[Upsert] err: " + err);
            return send(500);
          } else if (doc) {
            return send({
              success: true
            });
          } else {
            return send({
              "_id": res.id
            }, 201);
          }
        });
      });
    } else {
      return send(500);
    }
  });
});

action('deleteAccount', function() {
  return db.remove(params.id, this.doc.rev, function(err, res) {
    if (err) {
      console.log("[DeleteAccount] err: " + err);
      return send(500);
    } else {
      return send(204);
    }
  });
});

action('deleteAllAccounts', function() {
  var deleteAccounts,
    _this = this;
  deleteAccounts = function(accounts, callback) {
    var account, id;
    if (accounts.length > 0) {
      account = accounts.pop();
      id = account.value._id;
      return db.remove(id, account.value._rev, function(err, res) {
        if (err) {
          return callback(err);
        } else {
          return deleteAccounts(accounts, callback);
        }
      });
    } else {
      return callback();
    }
  };
  return accountManager.getAccounts(function(err, accounts) {
    var _this = this;
    if (err) {
      return send(500);
    } else {
      return deleteAccounts(accounts, function(err) {
        if (err) {
          return send(500);
        } else {
          return send(204);
        }
      });
    }
  });
});
